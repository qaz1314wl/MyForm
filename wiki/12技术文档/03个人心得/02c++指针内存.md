#一、指针
##1、一级指针和二级指针，以基本变量为例
int* x=0与int* x=NULL为相同意思
###代码

	#include<iostream>
	int main()
	{
	using namespace std;
	double *pt=NULL,*pd=NULL;
	double **ps=NULL;
	double xl = 3.4;
	cout.setf(ios_base::fixed, ios_base::floatfield);
	cout << xl<< endl;
	pt = &xl;
	ps = &pt;
	pd = pt;
	cout << &pd << endl << pd << endl << *pd << endl
		<< "分 割 线\n";
	cout << &pt<<endl<<pt<<endl<<*pt<<endl//<<*(&pt)<<endl *(&pt)==pt
		<<"分 割 线\n";
	cout << &ps<<endl<<ps << endl << *ps << endl<<**ps<<endl;//说明指向指针的指针,二级指针
	//pd = &pt;无法将指针本身的地址传给指针
	pd = (double *)&pt;
	cout << " 分 割 线 \n";
	cout << &pd << endl << pd <<endl<< *pd << endl;
	return 0;
	}
###输出结果

	3.400000
	0x73fe20
	0x73fe10
	3.400000
	分 割 线
	0x73fe28
	0x73fe10
	3.400000
	分 割 线
	0x73fe18
	0x73fe28
	0x73fe10
	3.400000
	 分 割 线
	0x73fe20
	0x73fe28
	0.000000

###说明
假设pt、pd为一级指针，ps为2级指针，xl为double类型变量

	pt = &xl;

一、当非空指针且指向变量时，*pt为所指变量的内存的值、&pt为指针所在的内存地址、pt为指针所指向变量的内存的地址(即&(*pt))

	pd = pt;
	//pd = &pt错误，无法指向一级指针地址
二、当非空指针指向指针所指向的变量内存地址时，*pd为指针所指向指针的所指向变量的内存的值、&pd为指针所在的内存地址、pd为指针所指向指针的所指向变量的内存的地址(即&(*pd))，<font color=red>因为赋予pd的为pt所指向的变量的内存地址，非pt的内存地址</font>

	ps = &pt;

三、	当二级指针指向指针的地址时，&ps为二级指针所在地址，
ps为二级指针指向指针的地址，*ps为二级指针指向的指针所指向的地址，**ps为二级指针指向的指针所指向的地址的值。

	pd = (double *)&pt;

四、一级指针可通过强制转换，指向一级指针地址。&pd为一级指针所在地址，pd为一级指针所指向一级指针的地址，<font color=red>*pd为什么是0,暂时不清楚，但是如果要获取真正的值，要将pd转换成真正的二级指针 **((double **)pd) </font>
##2、指针和const
const放*前，禁止改变指针所指向变量值
	int const *a=NULL;
	const int  *a=NULL;
const 放*后，禁止修改指针所指向变量地址


前后都放，则两者都不能改变
	int * const b=NULL;

若要用指针指向const常量，则要用const放*前的指针。
同理，上述三种类型的一级指针，只能用对应类型的二级指针来指向。
###利用const指针使用数组间函数
	#include<iostream>
	using namespace std;
	void ranged(const double*sta,const double *end);
	int main()
	{
		double arr[5]{3.4, 4.4, 5.4, 6.4, 7.4};
		ranged(arr, arr + 5);
		return 0;
	}
	
	void ranged(const double*sta,const double *end)
	{
		const double *p = NULL;
		double sum=0;
		for (p = sta; p != end; p += 1)
			sum += *p;
		cout << sum << endl;
	}
##3、指针和new、delete
一、new完了必须delete，释放new的内存空间,delete后指针可能还是指向同一块，但值已经修改，内存空间也可被下次利用
如：

	pt =(int *)0xB8000000;
	delete pt;
	long long *pn = new long long;
	delete pn;
二、delete和delete[]区别

delete 释放new分配的单个对象指针指向的内存，即用来释放内存，且只用来释放ptr指向的内存。

delete[] 释放new分配的对象数组指针指向的内存，即用来释放rg指向的内存，还逐一调用数组中每个对象的destructor
###注意点
1、简单类型(包括结构体)，使用new分配后的不管是数组还是非数组形式内存空间用delete和delete[]均可,原因在于：分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数，如：

	int *a = new int[10];
	delete a;
	delete [] a;
2、针对类Class，使用了delete来进行释放数组对象 则会出现进程异常

3、简单原则：new 和 delete、new[] 和 delete[] 对应使用
##4、函数指针
###代码
	void estimeate(int line, double(*pf)(int))
	{
		cout << (*pf)(line) << endl;
	}//例子1

	double*(*pa[2])(int) = { betsy,pam };
	cout << *(*pa[0])(3) << endl;//例子2

	typedef double *(*p_fun)(int);//使用函数指针类型的别名
	p_fun pl[2] = { betsy,pam };
	cout << *(*pl[0])(3) << endl;//例子3

	double*(*pa[2])(int) = { betsy,pam };
	double *(**pg)(int) = pa;
	cout << *(*pg[0])(3) << endl;
	cout << *pg[1](3) << endl;//例子4
	
	double*(*pa[2])(int) = { betsy,pam };
	double *(*(*pd)[2])(int) = &pa;
	cout << *(*pd)[0](3) << endl;
	cout << *(*(*pd)[1])(3) << endl;//例子5
###说明
函数返回值类型 (* 指针变量名) (函数参数列表);

指向函数的指针变量没有 ++ 和 -- 运算。

类型过于复杂时用auto申明即可(自动类型推断发生在编译期)。
##5、指针和数组
优先级：()>[]>*
###数组指针
	int (*p)[n];
执行p+1时，p要跨过n个整型数据的长度

数组指针也称指向一维数组的指针，亦称行指针
###指针数组
	int *p[n];
指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。
###一维数组名实际指的时数组的第一个元素的地址
而数组名作为指针来讲有特殊性，它正在它所指向的内存区域中，&a的值和a的数值是相同的
###二维数组
数组名相当于二维指针

	double **a = new double*[10];
	for (int i = 0; i < 10; i++) {
		a[i] = new double[10];
	} //=double a[10][10];
####代码
	#include<iostream>
	
	int main()
	{
		using namespace std;
		double a[10][10];
		a[0][0]=3;
		a[0][1]=3.5;
		a[1][0]=4;
		a[1][1]=5;
		cout<<**a<<endl;
		cout<<*(*a+1)<<endl;
		cout<<a[0]<<endl;
		cout<<&a[0][0]<<endl;
		cout<<&a[0][1]<<endl;
		return 0;
	}

#二、内存操作
##1、malloc相关
	#include<iostream>
	#include<string>
	#include<stdlib.h>
	int main()
	{
		using namespace std;
		int *p=NULL;
		cout<<sizeof(int)<<endl<<sizeof(double)<<endl<<"----------分割线001---------"<<endl;
		int *q=NULL;
		p=(int *)malloc(40);
		*p=1; 
		for(q=p+1;q<p+10;q++)
			*q=*(q-1)+1;
		for(q=p;q<p+10;q++)
			cout<<*q<<endl,cout<<q<<endl;
		free(p);
		cout<<"--------------分割线002-------------"<<endl; 
			for(q=p;q<p+1;q++)
			cout<<*q<<endl,cout<<q<<endl;
		return 0;
	}

malloc函数从堆上动态分配内存。

malloc申请一段连续的虚拟内存地址。malloc分配的内存空间在逻辑上是连续的，而在物理上可以不连续

	p=(int *)malloc(40);
使用完后用free释放，防止内存泄漏，同一块内存只能释放一次，空指针释放例外，等于什么也没做，几次都可以。

	free(p)

##2、colloc相关
它初始化了所分配的内存，所有位都是 0，其他和malloc相同。
##3、realloc相关
	p=(int *)realloc(p,40);
###realloc扩大内存空间时，并且内存地址和之前的连续还是不连续是不可靠的，内存地址上的值是可靠的。
原因如下：

	1、如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回原指针。
	2、如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存块位置。
####
###realloc缩小内存空间时，内存地址和之前的是连续的，值也是可靠的。
##memcpy
###代码
	#include<iostream>
	#include<string>
	#include<stdlib.h>
	int main()
	{
		using namespace std;
		int *p=NULL;
		int *q=NULL;
		int *o=NULL;
		p=(int *)malloc(sizeof(int)*2);
		*p=11;
		*(p+1)=22;
		o=(int *)malloc(sizeof(int)*4);
		memcpy(o,p,sizeof(p));
		inflatable *a = NULL;
		a = (inflatable *)malloc(sizeof(inflatable) * 2);
		a->name[0] = 'k';
		a->price = 13.0;
		a->volume = 14.0;
		(a+1)->name[0] = 'g';
		(a + 1)->price = 133.0;
		(a + 1)->volume = 144.0;
		inflatable *b = (inflatable *)malloc(sizeof(inflatable) * 4);
		memcpy(b, a, sizeof(inflatable) * 2);
		return 0;
	}
复制了8个字节(2个int类型)和64个字节(2个结构体)
###说明
可复制内存，很方便，无需重复赋值。
##4、memset
###代码
	#include<iostream>
	#include<string>
	#include<stdlib.h>
	#include<string.h>
	struct inflatable
	{
		char name[20];
		float volume;
		double price;
	};
	int main()
	{
		using namespace std;
		inflatable *a = NULL;
		a = (inflatable *)malloc(sizeof(inflatable) * 2);
		a->name[0] = 'k';
		a->price = 13.0;
		a->volume = 14.0;
		(a+1)->name[0] = 'g';
		(a + 1)->price = 133.0;
		(a + 1)->volume = 144.0;
		memset(a,0,sizeof(inflatable)*2);
		return 0;
	}
将结构体置空
###说明
用来对一段内存空间全部设置为某个字符，可以方便用来置空。

##5、注意点
1、指针可以轻松越界(超出所申请内存空间范围)，会引发错误，比如free的时候会有问题。

2、为了适应32位和64位系统，申请内存空间时用sizeof()，不要自己手写，如：

	p=(int *)malloc(40);//不好的方法
	(inflatable *)malloc(64);//不好的方法
	p=(int *)malloc(sizeof(int)*10);//正确方法
	(inflatable *)malloc(sizeof(inflatable) *2);//正确方法
3、

	p=(int *)malloc(sizeof(int)*1);
	*p=11;
	*(p+1)=22;
	p=(int *)realloc(p,sizeof(int)*10);
指针越过了所分配的内存，如果扩展后，还是原来连续的，则2个值都保留，如果不和之前连续的，则会丢失第二个值。不过因编译器不同，可能扩展后的地址赋值也会不正常。

4、

动态分配内存的基本原则 :

　　避免分配大量的小内存块。分配堆上的内存有一些系统开销，所以分配许多小的内存块
　　比分配几个大内存块的系统开销大。
 
　　仅在需要时分配内存。只要使用完堆上的内存块，就释放它。
    
　　总是确保释放以分配的内存。在编写分配内存的代码时，就要确定在代码的什么地方
　　释放内存。
      
　　 在释放内存之前，确保不会无意中覆盖堆上已分配的内存地址，否则程序就会出现内存
　　泄漏。在循环中分配内存时，要特别小心。
5、<https://blog.csdn.net/flowing_wind/article/details/81240910>
6、
常用数据类型对应字节数
  可用如sizeof（char),sizeof(char*)等得出

 32位编译器：

      char ：1个字节

      char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）

      short int : 2个字节

      int：  4个字节

      unsigned int : 4个字节

      float:  4个字节

      double:   8个字节

      long:   4个字节

      long long:  8个字节

      unsigned long:  4个字节

  64位编译器：

      char ：1个字节

      char*(即指针变量): 8个字节

      short int : 2个字节

      int：  4个字节

      unsigned int : 4个字节

      float:  4个字节

      double:   8个字节

      long:   8个字节

      long long:  8个字节

      unsigned long:  8个字节

**该文档由陈家栋整理**
